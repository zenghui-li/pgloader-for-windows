<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-01-04 Thu 08:37 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>S-SQL Examples A</title>
<meta name="author" content="Sabra Crolleton" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="style.css" />
<style>pre.src{background:#343131;color:white;} </style>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">S-SQL Examples A</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc723a3e">S-SQL Examples Home Page</a></li>
<li><a href="#alter-table">Alter Table</a>
<ul>
<li><a href="#alter-column">Altering Columns</a></li>
</ul>
</li>
<li><a href="#and">And</a></li>
<li><a href="#analyze">Analyze</a></li>
<li><a href="#any">Any, Any*</a></li>
<li><a href="#arrays">Arrays - see Array-Notes</a></li>
<li><a href="#as">As (sometimes referred to as Alias)</a></li>
<li><a href="#avg">Avg</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orgc723a3e" class="outline-2">
<h2 id="orgc723a3e"><a href="s-sql-examples.html">S-SQL Examples Home Page</a></h2>
<div class="outline-text-2" id="text-orgc723a3e">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="s-sql-a.html">A</a></td>
<td class="org-left"><a href="s-sql-b.html">B</a></td>
<td class="org-left"><a href="s-sql-c.html">C</a></td>
<td class="org-left"><a href="s-sql-d.html">D</a></td>
<td class="org-left"><a href="s-sql-e.html">E</a></td>
<td class="org-left"><a href="s-sql-f.html">F</a></td>
<td class="org-left"><a href="s-sql-g.html">G</a></td>
<td class="org-left"><a href="s-sql-h.html">H</a></td>
<td class="org-left"><a href="s-sql-i.html">I</a></td>
<td class="org-left"><a href="s-sql-j.html">J</a></td>
<td class="org-left"><a href="s-sql-k.html">K</a></td>
<td class="org-left"><a href="s-sql-l.html">L</a></td>
<td class="org-left"><a href="s-sql-m.html">M</a></td>
<td class="org-left"><a href="s-sql-n.html">N</a></td>
<td class="org-left"><a href="s-sql-o.html">O</a></td>
<td class="org-left"><a href="s-sql-p.html">P</a></td>
<td class="org-left"><a href="s-sql-r.html">R</a></td>
<td class="org-left"><a href="s-sql-s.html">S</a></td>
<td class="org-left"><a href="s-sql-t.html">T</a></td>
<td class="org-left"><a href="s-sql-u.html">U</a></td>
<td class="org-left"><a href="s-sql-v.html">V</a></td>
<td class="org-left"><a href="s-sql-w.html">W</a></td>
<td class="org-left"><a href="s-sql-special-characters.html">Special Characters</a></td>
<td class="org-left"><a href="calling-postgresql-stored-functions.html">Calling Postgresql Stored Functions and Procedures</a></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-alter-table" class="outline-2">
<h2 id="alter-table">Alter Table</h2>
<div class="outline-text-2" id="text-alter-table">
<div class="org-src-container">
<pre class="src src-lisp">(query (<span class="org-builtin">:alter-table</span> <span class="org-string">"countries"</span> <span class="org-builtin">:add-column</span> <span class="org-string">"stuff4"</span> <span class="org-builtin">:type</span> integer <span class="org-builtin">:default</span> 0))

(query (<span class="org-builtin">:alter-table</span> <span class="org-string">"countries"</span> <span class="org-builtin">:add-column</span> <span class="org-string">"stuff4"</span> <span class="org-builtin">:type</span> integer))

(query (<span class="org-builtin">:alter-table</span> <span class="org-string">"countries"</span> <span class="org-builtin">:add-column</span> <span class="org-string">"stuff4"</span> <span class="org-builtin">:type</span> (or db-null integer)))

</pre>
</div>

<p>
The difference between these versions is how they handle nulls. The first will generate a column that cannot be null and will set a default of 0. The second will not set a default but will still generate a column that cannot be null. The third will not set a default and the column is allowed to be null. Note that because the table name is in double quotes, if you have a multiple word table name, the words must be separated by the normal sql underscores, not the normal "lispy" hyphens.
</p>

<p>
You can use sql-compile to build the alter-table statements dynamically like so:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((table <span class="org-string">"countries"</span>) (column <span class="org-string">"stuff4"</span>))
  (query (sql-compile `(<span class="org-builtin">:alter-table</span> ,table <span class="org-builtin">:add-column</span> ,column
                        <span class="org-builtin">:type</span> (or db-null integer)))))

</pre>
</div>
</div>

<div id="outline-container-alter-column" class="outline-3">
<h3 id="alter-column">Altering Columns</h3>
<div class="outline-text-3" id="text-alter-column">
<p>
At the moment, altering columns requires that you still include a blank :type keyword.
</p>

<p>
As an example, assume you created a table named "test2" with a column named "description" with a not null constraint
</p>

<p>
and you want to drop the not null constraint on the table. Either of the following will work
</p>

<p>
(the only differences being whether you  quote the names or use strings for the names):
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (<span class="org-builtin">:alter-table</span> <span class="org-string">"test2"</span> <span class="org-builtin">:alter-column</span> <span class="org-string">"description"</span> <span class="org-builtin">:type</span> (<span class="org-builtin">:drop</span> not-null)))

(query (<span class="org-builtin">:alter-table</span> 'test2 <span class="org-builtin">:alter-column</span> 'description <span class="org-builtin">:type</span> (<span class="org-builtin">:drop</span> not-null)))

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-and" class="outline-2">
<h2 id="and">And</h2>
<div class="outline-text-2" id="text-and">
<div class="org-src-container">
<pre class="src src-lisp">    (query (<span class="org-builtin">:select</span> 'countries.name
                  <span class="org-builtin">:from</span> 'countries 'regions
                  <span class="org-builtin">:where</span> (<span class="org-builtin">:and</span> (<span class="org-builtin">:=</span> 'regions.name <span class="org-string">"North America"</span>)
                               (<span class="org-builtin">:=</span> 'regions.id 'countries.region-id))))

  ((<span class="org-string">"Bermuda"</span>) (<span class="org-string">"Canada"</span>) (<span class="org-string">"Greenland"</span>) (<span class="org-string">"Mexico"</span>) (<span class="org-string">"US"</span>))

  (query (<span class="org-builtin">:select</span> 'countries.name
                  <span class="org-builtin">:from</span> 'countries 'regions
                  <span class="org-builtin">:where</span> (<span class="org-builtin">:and</span> (<span class="org-builtin">:=</span> 'region-id 'regions.id)
                               (<span class="org-builtin">:=</span> 'regions.name <span class="org-string">"Central America"</span>)
                               (<span class="org-builtin">:&lt;</span> 'latitude 12))))

((<span class="org-string">"Costa Rica"</span>) (<span class="org-string">"Panama"</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-analyze" class="outline-2">
<h2 id="analyze">Analyze</h2>
<div class="outline-text-2" id="text-analyze">
<p>
The <a href="https://www.postgresql.org/docs/current/sql-analyze.html">official Postgresql documents</a> note that analyze collects statistics about a database and provides various options, whether you want specific tables and columns or the entire database, etc. The following is a series of examples of how it can be used in s-sql with increasing levels of complexity. Options can be set to true with t, 1 or :on and set to false with :nil 0 or off.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (<span class="org-builtin">:analyze</span>))

(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:verbose</span>))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Now specifying just analyzing table t1</span>
(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:verbose</span> <span class="org-builtin">:tables</span> 't1))

(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:verbose</span> <span class="org-builtin">:tables</span> <span class="org-builtin">:t1</span>))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Now specifying just analyzing tables t1 and t2</span>
(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:verbose</span> <span class="org-builtin">:tables</span> <span class="org-builtin">:t1</span> <span class="org-builtin">:t2</span>))

(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:verbose</span> <span class="org-builtin">:tables</span> 't1 't2))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Now specifying columns in tables t1 and t2</span>
(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:verbose</span>
        <span class="org-builtin">:tables</span> (<span class="org-builtin">:t1</span> 't1c1 't1c2) (<span class="org-builtin">:t2</span> 't2c1 't2c2 't2c3)))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Alternative syntax for the columns</span>
(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:verbose</span> <span class="org-builtin">:tables</span> (<span class="org-builtin">:t1</span> <span class="org-builtin">:t1c1</span> <span class="org-builtin">:t1c2</span>)))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Starting to look at more specific options</span>
(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:option</span> (<span class="org-builtin">:verbose</span> t)
                 <span class="org-builtin">:tables</span> (<span class="org-builtin">:t1</span> 't1c1 't1c2) (<span class="org-builtin">:t2</span> 't2c1 't2c)))
<span class="org-comment-delimiter">;; </span><span class="org-comment">The following will set option verbose to true, skip-locked to false</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">and buffer-usage-limit to 70MB</span>
(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:option</span> (<span class="org-builtin">:verbose</span> 1) (<span class="org-builtin">:skip-locked</span> 0) (<span class="org-builtin">:buffer-usage-limit</span> <span class="org-string">"70MB"</span>)
                 <span class="org-builtin">:tables</span> (<span class="org-builtin">:t1</span> 't1c1 't1c2) (<span class="org-builtin">:t2</span> 't2c1 't2c)))
<span class="org-comment-delimiter">;; </span><span class="org-comment">The following will set option verbose to true, skip-locked to false</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">and buffer-usage-limit to 70MB</span>
(query (<span class="org-builtin">:analyze</span> <span class="org-builtin">:option</span> (<span class="org-builtin">:verbose</span> t) (<span class="org-builtin">:skip-locked</span> nil) (<span class="org-builtin">:buffer-usage-limit</span> <span class="org-string">"70MB"</span>)
                 <span class="org-builtin">:tables</span> (<span class="org-builtin">:t1</span> 't1c1 't1c2) (<span class="org-builtin">:t2</span> 't2c1 't2c)))

</pre>
</div>
</div>
</div>
<div id="outline-container-any" class="outline-2">
<h2 id="any">Any, Any*</h2>
<div class="outline-text-2" id="text-any">
<p>
Any needs to be considered as a special case. Quoting Marijn Haverbeke here,"Postgres has both a function-call-style any and an infix any, and S-SQL's syntax doesn't allow them to be distinguished." As a result, postmodern has a regular :any sql-op and a :any* sql-op, which expand slightly differently.
</p>

<p>
In general, the any qualifier in an sql statement looks at a subquery and does a comparison against that subquery. Sticking with our countries table, we have latitude, longitude data for every country (I'm not sure whether my table pulled the capital cities or the geographic center) and some designated a region for each country, so we have a region-id that matches the primary key 'id' in a regions table.
</p>

<p>
Out of curiosity, let's determine which countries in "North America" have a longitude less than any country in "South America". The standard sql could look like this:
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (query <span class="org-string">"select countries.name</span>
<span class="org-string">               from countries,regions</span>
<span class="org-string">               where regions.id=region_id</span>
<span class="org-string">               and regions.name='North America'</span>
<span class="org-string">               and longitude &gt; any(select longitude</span>
<span class="org-string">                                          from countries, regions</span>
<span class="org-string">                                          where region_id = regions.id</span>
<span class="org-string">                                          and regions.name='South America')"</span>)

((<span class="org-string">"Bermuda"</span>) (<span class="org-string">"Greenland"</span>))
</pre>
</div>

<p>
This can be re-phrased in s-sql as
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query  (<span class="org-builtin">:select</span> 'countries.name
         <span class="org-builtin">:from</span> 'countries 'regions
                 <span class="org-builtin">:where</span> (<span class="org-builtin">:and</span> (<span class="org-builtin">:=</span> 'regions.id 'region-id)
                              (<span class="org-builtin">:=</span> 'regions.name <span class="org-string">"North America"</span>)
                              (<span class="org-builtin">:&gt;</span> 'longitude
                                  (<span class="org-builtin">:any</span>
                                   (<span class="org-builtin">:select</span> 'longitude
                                    <span class="org-builtin">:from</span> 'countries 'regions
                                            <span class="org-builtin">:where</span> (<span class="org-builtin">:and</span> (<span class="org-builtin">:=</span> 'regions.id 'region-id)
                                                         (<span class="org-builtin">:=</span> 'regions.name
                                                             <span class="org-string">"South America"</span>))))))))

((<span class="org-string">"Bermuda"</span>) (<span class="org-string">"Greenland"</span>))
</pre>
</div>

<p>
Subselects work fine in both regular sql and s-sql. If you have already calculated your subselect and put it in a variable, that variable can be a list or a vector and whether you should use the :any sql-op or the :any* sql-op depends on your phrasing. (Notice that the second variation has an asterisk).
</p>

<p>
The SQL keyword ANY can be used in a parameterized sql statement. The following two toy examples work in raw sql.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query <span class="org-string">"select name from countries where id=any($1)"</span>
       (vector 21 22))

((<span class="org-string">"Iceland"</span>) (<span class="org-string">"US"</span>))

(<span class="org-keyword">let</span> ((toy-query (vector 21 22)))
  (query <span class="org-string">"select name from countries where id=any($1)"</span>
         toy-query))

((<span class="org-string">"Iceland"</span>) (<span class="org-string">"US"</span>))
</pre>
</div>
<p>
Now using s-sql and keeping with the toy example, notice that using :any does not work, but using :any* does work.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((toy-query '(21 22)))
  (query (<span class="org-builtin">:select</span> 'name
          <span class="org-builtin">:from</span> 'countries
          <span class="org-builtin">:where</span> (<span class="org-builtin">:=</span> 'id (<span class="org-builtin">:any</span> '$1)))
         toy-query))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Evaluation aborted on</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">#&lt;CL-POSTGRES-ERROR:SYNTAX-ERROR-OR-ACCESS-VIOLATION {10030AF6A1}&gt;.</span>

(<span class="org-keyword">let</span> ((toy-query '(21 22)))
  (query (<span class="org-builtin">:select</span> 'name
          <span class="org-builtin">:from</span> 'countries
          <span class="org-builtin">:where</span> (<span class="org-builtin">:=</span> 'id (<span class="org-builtin">:any*</span> '$1)))
         toy-query))

((<span class="org-string">"Iceland"</span>) (<span class="org-string">"US"</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-arrays" class="outline-2">
<h2 id="arrays">Arrays - see <a href="array-notes.html">Array-Notes</a></h2>
<div class="outline-text-2" id="text-arrays">
</div>
</div>
<div id="outline-container-as" class="outline-2">
<h2 id="as">As (sometimes referred to as Alias)</h2>
<div class="outline-text-2" id="text-as">
<div class="org-src-container">
<pre class="src src-lisp">  (query (<span class="org-builtin">:select</span> (<span class="org-builtin">:as</span> 'countries.name 'country)
                (<span class="org-builtin">:as</span> 'regions.name 'region)
                <span class="org-builtin">:from</span> 'countries 'regions
                <span class="org-builtin">:where</span> (<span class="org-builtin">:and</span> (<span class="org-builtin">:=</span> 'regions.id 'region-id)
                             (<span class="org-builtin">:=</span> 'regions.name <span class="org-string">"Central America"</span>)))
       <span class="org-builtin">:alists</span>)

(((<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"Belize"</span>) (<span class="org-builtin">:REGION</span> . <span class="org-string">"Central America"</span>))
 ((<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"Costa Rica"</span>)  (<span class="org-builtin">:REGION</span> . <span class="org-string">"Central America"</span>))
 ((<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"El Salvador"</span>)  (<span class="org-builtin">:REGION</span> . <span class="org-string">"Central America"</span>))
 ((<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"Guatemala"</span>)  (<span class="org-builtin">:REGION</span> . <span class="org-string">"Central America"</span>))
 ((<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"Panama"</span>) (<span class="org-builtin">:REGION</span> . <span class="org-string">"Central America"</span>))
 ((<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"Nicaragua"</span>) (<span class="org-builtin">:REGION</span> . <span class="org-string">"Central America"</span>)))
</pre>
</div>

<p>
The following uses aliases for both columns and tables in the from and inner-join clauses:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (<span class="org-builtin">:order-by</span>
      (<span class="org-builtin">:select</span> (<span class="org-builtin">:as</span> 'recs.firstname 'firstname)
               (<span class="org-builtin">:as</span> 'recs.surname 'surname)
               <span class="org-builtin">:distinct</span>
               <span class="org-builtin">:from</span> (<span class="org-builtin">:as</span> 'cd.members 'mems)
               <span class="org-builtin">:inner-join</span> (<span class="org-builtin">:as</span> 'cd.members 'recs)
               <span class="org-builtin">:on</span> (<span class="org-builtin">:=</span> 'recs.memid 'mems.recommendedby))
      'surname 'firstname))
</pre>
</div>

<p>
Note: Postmodern does not allow you to create an unescaped string alias. In other words, you cannot generate this:
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span class="org-string">"select sum(slots as "</span>Total Slots<span class="org-string">" from cd.bookings"</span>
</pre>
</div>
<p>
without using :raw
</p>
</div>
</div>

<div id="outline-container-avg" class="outline-2">
<h2 id="avg">Avg</h2>
<div class="outline-text-2" id="text-avg">
<p>
Simple example easily applicable to max and min:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(query (<span class="org-builtin">:select</span> (<span class="org-builtin">:avg</span> 'longitude)
        <span class="org-builtin">:from</span> 'countries 'regions
                <span class="org-builtin">:where</span> (<span class="org-builtin">:and</span> (<span class="org-builtin">:=</span> 'regions.id 'region-id)
                             (<span class="org-builtin">:=</span> 'regions.name <span class="org-string">"North America"</span>))))

((-17939/200))
</pre>
</div>
</div>
</div>
</div>
</body>
</html>